# int类型需要在最开始赋值
# ANSI C只能在代码开头定义变量，C99可以在任何地方定义变量
# scanf中的条件是一定要输入的文字，而非显示出来的文字
#const变量一般强调全大写
#表达式，运算符（+-*/%）+算子（运算得值）
#单目运算符优先级>乘除取模>加减>赋值
# 复合赋值,+-*/%=,++,--,前缀后缀，a++在前为原值，++a在后为+1之后的值
#所有关系运算符优先级比算术运算的低，但是比赋值运算的高
#判断是否相等==和!=的优先级比其他的低，而连续的关系运算符是从左到右进行的
#if else 后面不带大括号情况下，仅紧跟条件当前行语句直到;有效
#if和while的区别仅仅在于一次性还是反复多次地做
#测试程序常常需要使用边界数据
#结束一个语句要么大括号{}要么分号；do-while语句最后一定要有分号，否则判定为未结束语句
#do-while优先进循环体再判断条件，while先判断条件再进循环体，无论如何都会执行至少一次然后判断条件
#for (i=0;i<n;i++)则循环次数为n，i的值为n（当i=n时跳出循环），循环控制变量为i；
#任何一个for循环都能改成一个while循环
#for中的每一个表达式都可以被省略
#如果循环有固定次数，使用for循环；如果必须执行一次，则用do_while;其他情况用while；
#std:io/bool
#C语言实际上没有真正的布尔量bool类型，实际上仍然是整数；
#逻辑运算，结果只有0和1，逻辑量是关系运算或逻辑运算的结果；
| !  | 逻辑非 |   !a   |   当a为true，结果false；当a为flase，结果true         |
| && | 逻辑与 | a && b |   如果a.b均为true，则结果true；否则false             |
| || | 逻辑或 | a || b |   a.b其中一个true，则结果true，都false，则结果false   |
#优先级! > && > ||
#短路：从左到右；对于&&，左边false则不做右边；对于||，左边true则不做右边；
#不要把赋值，或者复合赋值组合进表达式！
# 不希望使用嵌套表达式；
# 逗号运算符是级别最低的；主要在for循环中使用；
# 没有大括号的情况下，else总要和最近的if匹配；
#C语言的缩进不能代表if-else的匹配；
#switch-case语句控制表达式类型只能是整数int；常数也可以是计算表达式（C99才支持）；
#switch-case语句所有print都是在一个空间，case仅仅表达从哪里开始，通过break结束；没有break就一直进入下一个case执行；
#对一个整数做%10的操作，可以得到它的个位数。对一个整数做/10的操作，可以得到它的十位数。再对2者的结果做%10，就可以得到原来的十位数;
#if中0代表不成立，非0就会执行，一定要注意warning；
#goto需要做一个下标，当执行完成自动跳到该位置，特别适合多重循环语句；
#定义数组 <类型>变量名称[元素数量]  类型是指数组中每一个单元的类型。元素必须是整数。C99之前：元素必须是编译时刻确定的字面量；
#数组 是一种容器。特点是：其中所有的元素具有相同的数据类型。一旦创建，不能改变大小。*（数组中的元素在内存中是连续依次排列的）；
#int a[10],一个int数组，拥有a[0]-a[9]十个单元。每个单元都是一个int变量。可以出现在赋值的左边或右边，左边是写入，右边是读取，如a[2]=a[1]+6。*在赋值左边叫左值；
#数组的单元：数组的每个单元就是数组类型的一个变量。使用数组时放在[]中的数字叫做下标或索引，下标从0开始记数。最大个数是数组下标减一；
#有效的下标范围：编译器不会检测下标是否越界，不论左值还是右值。但是如果越界，一旦运行，可能导致程序崩溃，segmentation fault，也可能不严重。所以要保证下标值：[0～数组下标-1]；
#可以创建下标0的数组，但是没有用，无空间赋值；
#函数是一块代码，接收零个或多个参数，做一件事，并返回零个或一个值；
#函数定义，函数头(返回类型+函数名+(参数表))+函数体。void类型不直接返回值。
#调用函数：函数名(参数值)。()起到了表示函数调用的重要作用。即使没有参数也需要()。如果有参数，则需要给出正确的数量和顺序。这些值会被按照顺序依次采用来初始化函数中的参数；
#函数返回：函数知道每一次是哪里调用它，会返回到正确的地方；
#从函数中返回值：return停止函数的运行，并返回一个值。写法1:return;写法2:return表达式；
#从函数中返回值：可以把值赋给变量。可以把值再传给函数。甚至可以舍弃值；
#没有返回值的函数：void函数名（参数表）。不使用带值的return。可以没有return。调用的时候不能做返回值的赋值；如果函数有返回值，则必须使用带值的return；
#函数先后关系：C编译器自上而下分析代码，函数一般写在main上面，当它看到main中调用时，需要知道调用的函数样子（即要几个参数，每个参数的类型，返回什么类型）；
#如果函数在下面，则需要在main上方声明类型。函数头，以分号";"结尾，就构成了函数的原型。函数原型目的是告诉编译器这个函数长什么样的（名称+参数（数量及类型）+返回类型；
#调用函数：如果函数有参数，调用函数时必须传递给它数量、类型正确的值。可以传递给函数的值是表达式的结果，包括：字面量，变量，函数的返回值，计算的结果；
#类型不匹配时：调用函数时给的值与参数的类型不匹配是C语言传统上最大的漏洞。编译器会悄悄自动转换，但可能不是用户所期望的转换。后续的C++/Java在这方面做的很严格；
#C语言在调用函数时，永远只能传值给函数；
#传值：每个函数都有自己的变量空间，参数也位于这个独立的空间中，和其它函数没有关系；
#local（本地/局部）变量：函数每次运行，都产生一个独立的变量空间，在这个空间中的变量，是函数这次运行所独有的，称作本地变量。定义在函数内部的变量就是本地变量。参数也是本地变量；
#变量的生存期和作用域：生存期指什么时候这个变量产生了，什么时候它消亡了。作用域：在代码的什么范围内可以访问这个变量（这个变量可以起作用）。对于本地变量，这两个问题的答案是统一的：大括号内（即：块）；
#本地变量的规则：本地变量是定义在块内的。它也可以定义在函数块内。也可以定义在语句块内。甚至可以随便拉一堆大括号来定义变量。程序进入这个块之前，其中的变量不存在，离开这个块，其中的变量也随之消失。块外面定义的变量在里面仍然有效；块里面定义了和外面同名的变量则覆盖外面的。不能在同一个块内定义同名的变量。本地变量不会被默认初始化。参数在进入函数的时候被初始化了；
#没有参数时，void f(void)代表不接收任何参数。void f()代表参数未知，但不代表没有参数，编译器会猜类型；
#调用函数的时候，圆括号里的逗号运算符是标点符号，不是运算符f(a,b)。但是如果f((a,b))，则要先计算括号内的运算，再进行调用，这时就是运算符；
#C语言不允许函数嵌套定义。可以在一个函数内放另一个函数的声明，但是不能放另一个函数的body定义；
#关于main：int main()也是一个函数。return 0是有意义的；
#二维数组遍历用两重循环。a[i][j]表示第i行第j列上的单元。a[i,j]中逗号运算符，先计算然后再输出，这个写法对于二维数组是错误的；
#二维数组的初始化：列数必须给出，行数可以由编译器来做。每个{}使用逗号分隔。最后的逗号可以存在，有古老的传统。如果省略，表示补零。也可以用定位（C99 Only）；
#数组的集成初始化：直接用大括号给出数组所有元素的初始值。不需要给出数组的大小，编译器自动计算大小；
#集成初始化时的定位：用[n]在初始化数据中给出定位。没有定位的数据接在前面位置的后面。其他位置的值补零。也可以不给出数组大小，让编译器算。特别时候初始数据稀疏的项目；
#数组的大小：sizeof给出整个数据所占据的内容大小，单位是字节。sizeof(a)/sizeof(a[0]),sizeof(a[0])给出数组中单个元素的大小，于是相除就得到整个数组的长度。这样的代码，一旦修改数组中的数据，不需要更改遍历的代码；
#数组的赋值：数组本身不能被赋值。要把一个数组所有元素交给另一个数组，必须采用遍历；
#数组实际上是一个const，不能直接拿一个数组变量赋给另一个数组变量；
#遍历数组：通常使用for循环，让循环变量i从0到<数组的长度，这样循环体内最大的i正好是数组的最大的有效下标；常见错误：循环条件结束时<=数组长度，或离开循环后，继续用i的值来做数组元素的下标（离开循环后，自加结果就是数组无效的下标）；
#数组作为函数时，往往必须用再另一个参数来传入数组的大小。Reason：数组作为函数的参数时：不能在[]中给出数组的大小。不能再利用sizeof来计算数组的元素个数；
#
#
#
#
#
#
#
#
#